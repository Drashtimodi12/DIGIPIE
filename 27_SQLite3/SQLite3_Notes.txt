** What is SQLite used for?
==  SQLite is a database management system used to store and manage data in a structured format. 
    It is often used in applications that need to save data locally on a device or computer, such as 
    mobile apps, desktop software, and embedded systems. SQLite allows developers to create databases, 
    organize data into tables, and perform operations like inserting, updating, and querying data.



** What is SQLite3?
==  SQLite3 is a lightweight, simple database that stores all your data in one single file on your computer.
    It is one of the easiest databases to use, especially for beginners, because:
No server installation needed
No setup required
Runs inside your application
Uses one small file to store everything
    Think of SQLite as a small notebook where your program can write and read data.



** Why is it called SQLite?
==  SQL ‚Üí Structured Query Language (language for databases)
    Lite ‚Üí Lightweight (very small and easy to use)
    3 ‚Üí Version 3 of SQLite



** What type of database is SQLite?chevron
==  SQLite is a type of relational database management system (RDBMS). It allows users to store, manage, 
    and retrieve data in a structured format organized into tables with rows and columns. Users can define 
    relationships between different tables, perform queries to retrieve specific data, and execute 
    transactions to ensure data integrity.



** Where is SQLite used?
==  Python comes with SQLite built-in, so you don't need to install anything.
    SQLite is used almost everywhere:
    üì± Mobile apps (Android, iOS)
    üñ•Ô∏è Desktop apps
    üåê Browsers (Chrome, Firefox)
    üß™ Small projects
    üë©‚Äçüíª Learning database programming
    üß† Python applications



** How SQLite stores data?
==  SQLite stores everything inside a single .db file like:
        mydatabase.db;  student.db
    This file contains tables, rows, and columns ‚Äî just like Excel, but more powerful.



** Why beginners love SQLite?
==  Very easy to start; No server required; Fast and secure
    Works with Python using the module:     ******import sqlite3******



** fetchone()
==  Returns only one row from the result set.
    When to use:
        When you know only one record will match the query (e.g., searching by ID).
        When you want to fetch results row by row inside a loop.

** fetchmany(size)
==  Returns a specific number of rows from the result set.
    When to use:
        When you want results in chunks.
        Useful for large databases to reduce memory usage.

** fetchall()
==  Returns all remaining rows from the result set.
    When to use:
        When the result is small.
        When you want to process all data at once.



** Most important basic SQLite commands.
==  1. Create a Database:-  In SQLite, the database is just a file:
        import sqlite3
        con = sqlite3.connect("mydatabase.db")
    
==  2. Create Table
        CREATE TABLE student (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            age INTEGER,
        );

==  3. Insert Data into Table
    Insert single row:
        INSERT INTO student (name, age) VALUES ('Raj', 20);
    Insert multiple rows:
        INSERT INTO student (name, age) VALUES ('Priya', 22), ('Meet', 21);

==  4. Display All Data (SELECT)
        SELECT * FROM student;
    Select specific columns:
        SELECT name, age FROM student;
    Select with condition:
        SELECT * FROM student WHERE age = 21;

==  5. Update Data
        UPDATE student SET age = 23 WHERE name = 'Raj';

==  6. Delete Data
        DELETE FROM student WHERE id = 2;

==  7. Drop Table (Delete Entire Table)
        DROP TABLE student;

==  8. Add New Column
        ALTER TABLE student ADD COLUMN marks INTEGER;

==  9. Delete Column (SQLite doesn't support direct drop column)
        You have to create a new table.

==  10. Group by :   It is used to group rows that have the same values in a column and apply aggregate 
    functions on them.
    Count rows:
        SELECT COUNT(*) FROM student;
    Max, Min:
        SELECT MAX(age) FROM student;
        SELECT MIN(age) FROM student;
    Average:
        SELECT AVG(age) FROM student;
    Sum:
        SELECT SUM(age) FROM student;

== 11. HAVING (Short & Easy Notes)      It is used to filter groups created by GROUP BY.
    HAVING ‚Üí filters groups after grouping
    HAVING can use aggregate functions, WHERE cannot.
    WHERE ‚Üí filters rows before grouping

==  12.  Ordering & Limiting
    Order by ascending:
        SELECT * FROM student ORDER BY age ASC;
    Order by descending:
        SELECT * FROM student ORDER BY age DESC;
    Limit:
        SELECT * FROM student LIMIT 5;
        (This will show only first 5 rows.)
    LIMIT with OFFSET:  If you want to skip some rows:
        SELECT * FROM employee LIMIT 5 OFFSET 2;
        (This will skip the first 2 rows and show the next 5 rows.)

==  13.  WHERE with Operators
    Greater than:
        SELECT * FROM student WHERE age > 20;
    Between:
        SELECT * FROM student WHERE age BETWEEN 18 AND 25;  
    LIKE (pattern search):
        SELECT * FROM student 
        WHERE name LIKE 'P%'        # Name starting with P        Ex: Pooja, Priya
        OR name LIKE '%a'           # Name ends with a     Ex: Sneha, Riya
        OR name LIKE '%ri%'         # Name containing "ri" anywhere        Ex: Richa, Trisha, Priya
        OR name LIKE 'P__a'         # Name starting with P, ending with a, and exactly 4 letters, __ ‚Üí two characters in between       Ex: Pina, Pooa
        OR name LIKE '_____'        # Names with exactly 5 letters/characters      Ex: Sneha, Riyaan
        OR name LIKE '_r%'          # Second letter should be r        Ex: Kiran, Krishna, Srishti
        OR name LIKE 'P%i';         # Name starting with P and ending with i       Ex: Pavi, Purni



** SQLite Data Types.
==  SQLite accepts many type names but internally converts them into 5 storage classes.
    This means SQLite actually uses 5 main data types (called storage classes).
    All data you store will fall into one of these.

==  1. NULL:    Represents no value / empty value.
        Used when data is optional.     Ex: NULL

==  2. INTEGER(INT, SMALLINT, BIGINT):     
        Stores whole numbers (positive or negative, no decimals).
        Ex: 10, 0, -5, 1000
        SQLite stores integer values in: 1, 2, 3, 4, 6, or 8 bytes
            (Automatically depends on the size of the number ‚Äî no manual byte selection needed)
        Used for:       IDs, age, count, whole marks, quantity.

==  3. REAL/DECIMAL/NUMERIC (FLOAT, DOUBLE, BOOLEAN, DATE, DATETIME):    
    Stores decimal / floating-point numbers. Size Depends on digits    Ex: 5.6, 99.99, -3.14
        DECIMAL:    DECIMAL(total_digits, digits_after_decimal)     Ex: salary DECIMAL(10,2)    -- 45000.75
        BOOLEAN:    Stores True(1)/ False(0) values.
            is_active BOOLEAN   -- 1 for active, 0 for inactive
        DATE:   Stores date only.   Ex: '2000-12-01'
            SQLite stores as TEXT ('YYYY-MM-DD'), REAL (Julian day), or INTEGER (Unix timestamp).
        DATETIME:   Stores date and time.   Ex: '2025-12-01 10:15:00'
            Stored as TEXT ('YYYY-MM-DD HH:MM:SS'), REAL, or INTEGER.
    Used for:   Price, percentage, rating, measurement.


==  4. TEXT(CHAR, VARCHAR, CLOB):    
        Stores strings / characters.
        Stored exactly as entered.      Ex: 'Drashti', 'Surat', 'Python123'
        Used for:  Name, email, city, address, password, description.

==  5. BLOB(Binary Large Object)(BLOB, BINARY):    
        Stores raw data exactly as it is.
        Used for files and binary data.
        Ex: Images, PDFs, videos, audio, encrypted data.
        Used for: Saving profile pictures, documents, Multimedia files, etc.



** SQLite3 Constraints
==  Constraints are rules applied to columns or tables to enforce data integrity.
    They ensure that the data stored in the database is valid and consistent.
    
==  1. PRIMARY KEY:     Uniquely identifies each record in a table.
        Only one primary key per table.     Automatically NOT NULL.
        Ex: id INTEGER PRIMARY KEY
        Used for: Unique identifiers (IDs)

==  2. AUTOINCREMENT:   Used with INTEGER PRIMARY KEY to automatically increase value for each new row.
        Starts from 1 and increases by 1.
        Ex: id INTEGER PRIMARY KEY AUTOINCREMENT
        Used for: Auto-incrementing IDs

==  3. NOT NULL:    Ensures a column cannot have NULL values.
        Data must be provided when inserting.
        Ex: name TEXT NOT NULL
        Used for: Mandatory fields like Name, Email

==  4. UNIQUE:    Ensures all values in a column are unique.
        Can be applied to one or more columns.
        Ex: email TEXT UNIQUE
        Used for: Email, Username, Phone number
    UNIQUE + NOT NULL:   Combination ensures no duplicate and no empty value.
        Ex: username TEXT UNIQUE NOT NULL

==  5. DEFAULT:     Provides a default value if none is specified during insert.
        Ex: status TEXT DEFAULT 'Active'
        Used for: Default status, counters, flags

==  6. CHECK:   Ensures column values satisfy a condition.
        Used to restrict input values.
        Ex: age INTEGER CHECK(age >= 18)
        Used for: Age restrictions, valid ranges, custom rules

==  7. FOREIGN KEY:     Enforces referential integrity between two tables.
        A column in one table refers to the PRIMARY KEY in another table.
        Ex: order_id INTEGER,
            customer_id INTEGER,
            FOREIGN KEY(customer_id) REFERENCES customer(id)
        Used for: Linking tables (Orders ‚Üí Customers)

==  8. COMPOSITE KEY:   Primary key that uses more than one column.
        Ensures unique combination of values.
        Ex: PRIMARY KEY (student_id, course_id)
        Used for: Many-to-many relationships



**  SQLite3 Relationships.
==  In databases, relationships define how tables are connected to each other.
    SQLite3 supports three main types of relationships: One-to-One, One-to-Many, and Many-to-Many.

==  1. One-to-One (1:1):    Each row in Table A is linked to exactly one row in Table B, and vice versa.
        Usually, both tables share the same PRIMARY KEY, or one table has a UNIQUE FOREIGN KEY.
        Ex: CREATE TABLE person (person_id INTEGER PRIMARY KEY, name TEXT);
            CREATE TABLE passport (passport_id INTEGER PRIMARY KEY, person_id INTEGER UNIQUE, country TEXT,
                    FOREIGN KEY(person_id) REFERENCES person(person_id));
        Explanation:  Each person can have only one passport. `person_id` in `passport` references `person_id` in `person`.

==  2. One-to-Many (1:N):   Each row in Table A can be linked to multiple rows in Table B.
        Most common relationship in databases.
        Ex: CREATE TABLE customer (customer_id INTEGER PRIMARY KEY, name TEXT);
            CREATE TABLE orders (order_id INTEGER PRIMARY KEY, customer_id INTEGER, order_date TEXT, 
                    FOREIGN KEY(customer_id) REFERENCES customer(customer_id));
        Explanation:    A customer can place multiple orders, but each order belongs to one customer.

==  3. Many-to-Many (M:N):    Multiple rows in Table A can relate to multiple rows in Table B.
        Requires a junction table (also called a linking table) to store relationships.
        Ex: CREATE TABLE student (student_id INTEGER PRIMARY KEY, name TEXT);
            CREATE TABLE course (course_id INTEGER PRIMARY KEY, course_name TEXT);
            CREATE TABLE student_course (student_id INTEGER, course_id INTEGER,
                    PRIMARY KEY(student_id, course_id), FOREIGN KEY(student_id) REFERENCES student(student_id),
                    FOREIGN KEY(course_id) REFERENCES course(course_id));
        Explanation: A student can enroll in many courses. A course can have many students.
             `student_course` is the junction table that links students and courses.



** SQLite3 JOINS
==  JOINS are used to combine rows from two tables based on a related column (usually a foreign key).
    Let‚Äôs assume two tables:
    student
        id	name
        1	Raj
        2	Priya
        3	Meet
    course
        id	student_id	subject
        1	1	        Python
        2	1	        SQL
        3	2	        Django
    Here, course.student_id ‚Üí references ‚Üí student.id

==  1. INNER JOIN:  INNER JOIN ‚Üí Only matching rows
    Only matching rows from both tables
    If a student has no course ‚Üí they will NOT appear.
    Query:
        SELECT student.name, course.subject FROM student INNER JOIN course ON student.id = course.student_id;
    Output:
        name	subject
        Raj	    Python
        Raj	    SQL
        Priya	Django
    Meet is missing because he has no course.

==  2. LEFT JOIN (LEFT OUTER JOIN):     LEFT JOIN ‚Üí All from LEFT + matching from right
    All rows from the LEFT table + matching rows from RIGHT table
    If no match ‚Üí NULL is shown.
    Left table = student    Right table = course
    Query:
        SELECT student.name, course.subject FROM student LEFT JOIN course ON student.id = course.student_id;
    Output:
        name	subject
        Raj	    Python
        Raj	    SQL
        Priya	Django
        Meet	NULL

==  3. RIGHT JOIN:  RIGHT JOIN ‚Üí All from RIGHT + matching from left
    ‚ùå SQLite does NOT support RIGHT JOIN directly.
    But we can simulate it using LEFT JOIN by swapping tables.
    Simulated Right Join:
        SELECT student.name, course.subject FROM course LEFT JOIN student ON course.student_id = student.id;
    Equivalent to:
        RIGHT JOIN student ON student.id = course.student_id
    Output: 


==  4. FULL OUTER JOIN:     FULL JOIN ‚Üí All rows from both tables
    ‚ùå SQLite does not support FULL JOIN directly.
    But we can simulate it using UNION of left join and right join.
    Query:  -- LEFT JOIN Union -- RIGHT JOIN (simulated)
        SELECT student.name, course.subject FROM student LEFT JOIN course ON student.id = course.student_id
                UNION
        SELECT student.name, course.subject FROM course LEFT JOIN student ON course.student_id = student.id;
    Output (full result):
        name	subject
        Raj	    Python
        Raj	    SQL
        Priya	Django
        Meet	NULL
        NULL	Python?

==  5. CROSS JOIN:  CROSS JOIN ‚Üí All combinations (A √ó B). 
    Returns every combination (Cartesian product)
    No ON condition needed.
    If student = 3 rows and course = 3 rows ‚Üí output = 9 rows.
    Query:
        SELECT student.name, course.subject FROM student CROSS JOIN course;
    Output (sample):
        name	subject
        Raj	    Python
        Raj	    SQL
        Raj	    Django
        Priya	Python
        ...	    ...
    Used rarely; produces a huge table.

==  6. SELF JOIN: (Joining a table with itself)
    A Self Join is when a table is joined with itself as if it were two different tables.
    Used when:  Rows in the same table have a relationship with each other
    Example: employee ‚Üí manager, categories ‚Üí subcategories, friends list, prerequisites
    We use aliases (A, B) to treat the same table as two different tables.



** What is a Transaction? (Easy Explanation)
==  A transaction is a safe box for your database operations.
    Meaning:
        A transaction is a group of SQL operations executed together.
        If all queries are successful ‚Üí COMMIT
        If any query fails ‚Üí ROLLBACK
        This ensures your database never gets damaged or partially updated.

    Simple Real-Life Example
        Imagine you are sending money:
        Deduct ‚Çπ100 from your account
        Add ‚Çπ100 to your friend‚Äôs account
        If step 1 succeeds but step 2 fails ‚Üí BIG LOSS!
        So BOTH must happen together.
        This is handled using transactions. Without transaction unsafe



** What is an INDEX in SQLite?
==  An index in SQLite3 is a special data structure that helps the database find and retrieve rows faster, 
    just like a book, an index helps you quickly find a topic without reading every page.

    Without INDEX ‚Üí SQLite searches every row (slow)
    With INDEX ‚Üí SQLite jumps directly to the correct row (fast)
    It stores selected column values in sorted order.
    It does NOT change the actual table data.
    It is automatically used by SQLite when searching or filtering data.

==  Why INDEX is used? (Main Purpose) Advantages
        To speed up searching, filtering, JOIN operations, ORDER BY and GROUP BY
        INDEX improves read/search operations, not write.

==  Disadvantages of Index
    Slower INSERT   (Since index also updates)
    Takes extra storage     (Small amount, but still)

==  When should you NOT use INDEX?
        ‚ùå Do NOT create index on columns that change very frequently
        ‚ùå Do NOT index every column
        ‚ùå Do NOT index tiny tables (5‚Äì10 rows) ‚Üí no benefit
        ‚ùå Too many indexes slow down INSERT, UPDATE, DELETE
        (Because SQLite must update the index also)

==  How to Create an Index
    SYNTX:  *****CREATE INDEX index_name ON table_name(column_name);*****

==  How to View All INDEXES
        PRAGMA index_list('student');
    To see index details:
        PRAGMA index_info('idx_student_name');

==  How to Delete an Index
    *****DROP INDEX idx_student_name;*****

==  Types of INDEX in SQLite
        CREATE TABLE students ( id INTEGER PRIMARY KEY, name TEXT NOT NULL, 
                                email TEXT UNIQUE, city TEXT, age INTEGER  );

    1. NORMAL INDEX:    Used for faster searching on column.
        Example: Create index on city.
            CREATE INDEX IDX_STU_CITY ON students(city)
        Why?    If you search by city:
            SELECT * FROM students WHERE city = 'Surat';
        This will be very fast.

    2. UNIQUE INDEX: Prevents duplicate values + speeds up search.
        We can create a unique index on email (even though UNIQUE is already applied, both examples are valid).
        Example: Create index on email.
            CREATE INDEX IDX_STU_EMAIL ON students(email)
        Why?    Ensures no two students have the same email.

    3. MULTI-COLUMN INDEX (Composite Index):       Index on two or more columns together.
            CREATE INDEX IDX_STU_CITY_EMAIL ON students(city, email)
        Why?    Useful when you run queries like:
            SELECT * FROM students WHERE city = 'Mumbai' AND age = 20;
        SQLite uses this index for combined filtering.

    4. AUTOMATIC INDEX (Primary Key Index)
    SQLite automatically creates:
        PRIMARY KEY index
        UNIQUE constraint index
    You do NOT create these manually.
    Already created automatically:
        id INTEGER PRIMARY KEY     --> automatic index
        email TEXT UNIQUE          --> automatic unique index



** What is a VIEW?
==  A VIEW is like a saved SELECT query. It is a virtual table created from a SELECT query. 
    Think of it as:
        A virtual table
        it looks like a table
        it behaves like a table
        but it does not store data itself, it only shows data from other tables.

==  Why use views?
    To simplify complex queries
    To hide sensitive columns (like passwords, salary, IDs)
    To create reports using JOIN
    To avoid writing the same query again and again
    To give limited access to specific columns

    Real-life example:-     Think of a VIEW as a window:
                            Your house = original table
                            Window = view
                            You can see inside but not change the original structure.
    
==  Why Use a VIEW? (Advantages)
    Simplifies complex queries
        Instead of writing long JOIN queries again & again, create a VIEW once.
    Increases security
       Hide sensitive columns (like salary, password).
    Helps create reports
        Views are useful for dashboards or filtered results.
    Reduces repetitive code
        You can SELECT from a view just like a normal table.

==  ‚ùå Limitations of Views
    View does NOT store data.
    Some views cannot be updated (especially if they use JOINs, GROUP BY, etc.).
    Performance may be slower for very large tables.

==  How to Create a VIEW   Syntax
    ********CREATE VIEW view_name AS
            SELECT columns FROM table_name WHERE condition;*************

==  2 Types of Views in SQLite:
    1. Simple View
        Created using SELECT from one table
        Often updatable
        Easy to maintain
        Example:        CREATE VIEW view_student_basic AS SELECT id, name, city FROM student;

    2. Complex View
        Uses JOIN, GROUP BY, HAVING, functions
        Usually NOT updatable
        Example:        CREATE VIEW view_student_course AS SELECT s.name, c.subject
                        FROM student s JOIN course c ON s.id = c.student_id;

==  How to Use a VIEW:  A VIEW acts like a table.
    Just use:     *****SELECT * FROM view_student_basic;*******
    You can filter:     *********SELECT name FROM view_student_basic WHERE city = 'Surat';**********
    A view behaves like a shortcut to a query.

==  How to Update Data Using a View (When Allowed)
    SQLite allows updates only if view is simple.
    Example Simple View:        CREATE VIEW view_emp_salary AS SELECT emp_id, emp_name, emp_salary FROM employee;
    Update using View:      UPDATE view_emp_salary SET emp_salary = 50000 WHERE emp_id = 3;
    SQLite internally updates the original table.

==  When UPDATE is NOT Allowed
    Updates fail when view contains:
    JOIN, GROUP BY, DISTINCT, Aggregates (SUM, AVG), UNION
    Example (Not updatable):        CREATE VIEW view_sales_report AS SELECT dept, SUM(salary) AS total_salary
                                    FROM employee GROUP BY dept;
    Trying:     UPDATE view_sales_report SET total_salary = 50000;
    ‚ùå Error: View is not updatable

==  Replace an Existing View
    If you want to overwrite:   CREATE OR REPLACE VIEW view_name AS SELECT ...

==  Delete (Drop) a View    *********DROP VIEW IF EXISTS view_student_basic;************

